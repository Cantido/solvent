# Getting Started with Solvent

```elixir
Mix.install([:solvent])
```

## Introduction

Solvent is an event bus. It was designed to be extremely easy to use. There's no supervision hierarchy to set up, and no configuration required. You don't even need to `import` or `use` any modules if you don't want to.

<!-- livebook:{"break_markdown":true} -->



## Basic PubSub

At its core, Solvent stores and invokes function calls. Use `Solvent.subscribe/2` to subscribe a function call. The only other required value is the event type to match. The event's "type" is also known as a "topic." It just means the variety of event being published.

```elixir
{:ok, sub_id} =
  Solvent.subscribe("com.example.event.published", fn _type, _event_id ->
    IO.puts("Hello, world!")
  end)
```

This should return an `:ok` tuple containing the subscriber's ID. You don't need to keep this value unless you plan on unsubscribing later.

<!-- livebook:{"break_markdown":true} -->

Then, `Solvent.publish/1` will publish an event to trigger it.

```elixir
{:ok, event_id} = Solvent.publish("com.example.event.published")
```

This also returns an `:ok` tuple, this time with the event's ID, which is needed to get the event out of the event store. If you're running this via Livebook, you should see "Hello, world!" in your terminal.

<!-- livebook:{"break_markdown":true} -->

When an event is published, Solvent searches through all registered listener functions and invokes the functions whose types match the published event's type. This all happens in an isolated `Task`, so publishing an event is very fast. Subscriber functions themselves run inside their own `Task`, so they are completely isolated from one another.

## The Event Store

Events are not given directly to subscriber functions. Instead, only the event's type and ID are given, and you must fetch the event yourself. Solvent was designed this way to minimize the amount of data being copied between processes, which would slow things down. You can interact with the event store with the `Solvent.EventStore` module. For the most part, you will be using the `Solvent.EventStore.fetch/1` function to get an event.

```elixir
{:ok, event} = Solvent.EventStore.fetch(event_id)
```

The event store also keeps track of event acknowledgements.

## Acknowledging an Event

In order for the event store to stay small and quickly-searchable, the event store requires that events be acknowledged once the subscriber is done processing. The event store keeps track of acknolwedgements, and deletes the event once all subscribers have responded. Acknowledge events using the `Solvent.EventStore.ack/2` function.

```elixir
Solvent.EventStore.ack(event_id, sub_id)
```

## Module subscribers

Subscribing functions to the event bus is straightforward, but it can be disorganized. Solvent allows you to subscribe modules to the event bus as well, which gives you some extra tooling and useful defaults. To get started, `use` the `Solvent.Subscriber` module. You must also provide the `:match_type` option, which can be either a single event type or a list of event types.

```elixir
defmodule MyModuleSubscriber do
  use Solvent.Subscriber,
    match_type: "com.example.event.published"

  def handle_event(_type, event_id) do
    IO.puts("I'm responding to event #{event_id}!")
  end
end
```

Then you can subscribe this module anywhere, like your application's `start/2` function.

```elixir
Solvent.subscribe(MyModuleSubscriber)
```

If you run this code in Livebook, you'll notice one of the handy defaults that module subscribers provide: the module's name is provided as the subscriber ID. Module subscribers also automatically call `Solvent.EventStore.ack/2` once the `handle_event/2` function returns.

## Event data and the CloudEvents spec

Most events cannot be fully described by just a type. In Solvent, a type is required, but everything else is optional. Fortunately, `Solvent.publish/2` accepts a keyword list of options, one of which is `:data`.

```elixir
Solvent.publish(
  "com.example.event.published",
  data: %{hello: "world"}
)
```

The `:data` key on the resulting `Solvent.Event` struct is set to this value, so subscribers can use it after they fetch the event from the event store.

```elixir
Solvent.subscribe("data listener", "com.example.event.published", fn _type, event_id ->
  {:ok, event} = Solvent.EventStore.fetch(event_id)

  IO.puts("Subscriber got data #{inspect(event.data)}")

  Solvent.EventStore.ack(event_id, "data listener")
end)
```

Let's dive into the `Solvent.Event` struct and see what else is available.

```elixir
%Solvent.Event{
  data: nil,
  datacontenttype: nil,
  dataschema: nil,
  extensions: %{},
  id: "7cd94b9a-2073-48ff-ac76-67e6632d9907",
  source: "Solvent",
  specversion: "1.0",
  subject: nil,
  time: ~U[2022-05-25 15:51:23.232504Z],
  type: "com.example.event.published"
}
```

Events in Solvent follow the [CloudEvents specification](https://github.com/cloudevents/spec). This specification is a project of the Cloud Native Computing Foundation that aims describe event data in a common way. By adhering to this specification, Solvent events can be transmitted over any channel that has a CloudEvents binding defined for it. There are also other Elixir libraries that work with CloudEvents. Solvent allows you to specify all of these keys when publishing an event.

```elixir
Solvent.publish(
  "com.example.event.published",
  id: "my specific ID",
  source: "Livebook",
  subject: "getting-started.md",
  datacontenttype: "application/json",
  data: ~s({"foo":"bar"}),
  extensions: %{
    correlationid: "a correlation ID",
    causationid: "a causation ID"
  }
)
```

The `Solvent.Event.new/2` function has the same signature, so you can create events before publishing them. `Solvent.publish/1` accepts a `Solvent.Event` struct.

```elixir
Solvent.Event.new(
  "com.example.event.published",
  data: <<1, 2, 3, 4, 5>>
)
|> then(fn event ->
  %{event | extensions: %{correlationid: "1", causationid: "2"}}
end)
|> Solvent.publish()
```

## Summary

That's the extent of the Solvent event bus. This is what you should have gotten from this guide:

* Subscribe functions or modules to events with `Solvent.subscribe/2`
* Publish them with `Solvent.publish/2`
* Subscribers are called with the event type and event ID as arguments
* Subscribed functions and modules must fetch the event struct themselves, if they want it
* Subscriber functions must call `Solvent.EventStore.ack/2`; modules do this automatically
